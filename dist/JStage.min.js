(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.JStage = factory());
}(this, (function () { 'use strict';

/**
 * 元素脚本
 * @param {string} property
 * @param {mixed} value 变化值，不是目标值
 * @param {mixed} duration
 * @param {string} timingFunction
 * @param {int} delay 毫秒单位
 */
var Script = function(property, value, duration, delay, timingFunction) {
    this.transforms = ['scaleX', 'scaleY', 'skewX', 'skewY', 'rotate', 'translateX', 'translateY'];

    this.id = Script.i++;
    this.property = property;
    this.value = value;
    this.duration = this.normalizeTime(duration);
    this.timingFunction = !!timingFunction ? timingFunction : 'linear';
    this.delay = this.normalizeTime(delay);
    this.status = Script.IDLE;
};

Script.i = 0;
Script.IDLE = 0;
Script.EXECUTING = 1;
Script.SKIP = 2;
Script.COMPLETE = 3;

Script.prototype = {
    reset: function() {
        this.status = Script.IDLE;
    },

    executing: function() {
        this.status = Script.EXECUTING;
    },

    skip: function() {
        this.status = Script.SKIP;
    },

    complete: function() {
        this.status = Script.COMPLETE;
    },

    isExecuting: function() {
        return this.status === Script.EXECUTING;
    },

    isSkip: function() {
        return this.status === Script.SKIP;
    },

    isComplete: function() {
        return this.status === Script.COMPLETE;
    },

    normalizeTime: function(time) {
        if (!time) {
            return 0;
        }
    
        if (typeof time === 'number') {
            return time;
        } else if (time.indexOf('ms') > 0) {
            return time.slice(0, -2) - 0;
        } else if (time.indexOf('s') > 0) {
            return time.slice(0, -1) * 1000;
        } else if (isNaN(time)) {
            return time;
        }
    },

    /**
     * 根据运行进度来计算脚本当前进度的值
     * @param {float} progress
     */
    getProgressValue: function(progress) {
        return progress * this.value;
    }
};

var Obj = function(el, width, height, left, top) {
    this.el, this.state = {}, this.intermediateState = {}; // 中间状态
    this.setups = {}, this.loops = {}, this.propDiff = {}, this.executingScripts = {}, this.currentSetup, this.width, this.height, this.left, this.top, this.duration = 0;
    this.stage, this.status = Obj.IS_STATIC, this.setEl(el);
    this.setSize(width, height);
    this.setPosition(left, top);
};

Obj.PROP_DEFAULT = {
    scale   : 1,
    scaleX  : 1,
    scaleY  : 1,
    translateX  : 0,
    translateY  : 0,
    rotate  : 0,
    skew    : 0,
    skewX   : 0,
    skewY   : 0
};
Obj.TRANSFORMS = [
    'translateX',
    'translateY',
    'rotate',
    'skew',
    'skewX',
    'skewY',
    'scale',
    'scaleX',
    'scaleY',
];
Obj.INIT_SETUP = 'INIT_SETUP'; // 初始化状态
Obj.OPEN_SETUP = 'OPEN_SETUP'; // 开场状态
Obj.IS_IDLE = 0;
Obj.IS_COMPLETED = 2;
Obj.IS_ANIMATING = 3;
Obj.IS_STATIC = 4;

Obj.addBatchSetups = function(objs, setups) {
    objs.forEach(function(obj) {
        for (var offset in setups) {
            obj.addSetup(offset, setups[offset]);
        }
    });
};

Obj.prototype = {
    setState: function(prop, value) {
        this.state[prop] = value;
        return this;
    },

    /**
     *
     * @param {string} prop
     */
    getPropDefaultValue: function(prop) {
        if (undefined === Obj.PROP_DEFAULT[prop]) {
            return 0;
        } else {
            return Obj.PROP_DEFAULT[prop];
        }
    },

    createSetup: function(offset) {
        if (undefined === this.getSetup(offset)) {
            this.setups[offset] = {
                key: offset,
                scripts: [],
                setups: [],
                index: 0,
                startTimestamp: null
            };
        }
    },

    /**
     * 添加状态脚本
     * @param {string} offset
     * @param {array} scripts
     */
    addSetup: function(offset, scripts) {
        this.createSetup(offset);

        var setup = this.getSetup(offset);

        if (scripts instanceof Array && scripts.length > 0) {
            scripts.forEach(function(script) {
                this.addScript(offset, script);
            }, this);
        }

        setup.duration = this.getDuration(setup);

        return this;
    },

    /**
     *
     * @param {object} setups
     */
    addSetups: function(setups) {
        for (var offset in setups) {
            this.addSetup(offset, setups[offset]);
        }
    },

    addLoopSetup: function(offset, setupOffsets) {
        this.createSetup(offset);

        setupOffsets.forEach(function(setupOffset) {
            var setup = this.getSetup(setupOffset);

            if (setup) {
                this.getSetup(offset).setups.push(setup);
            }
        }, this);
    },

    addOpenSetup: function(scripts) {
        this.addSetup(Obj.OPEN_SETUP, scripts);
        return this;
    },

    /**
     * 为状态添加一个脚本
     * @param {string} offset
     * @param {object} script
     */
    addScript: function(offset, script) {
        this.createSetup(offset);

        this.status = Obj.IS_IDLE;

        this.setups[offset].scripts.push(
            new Script(script.property, script.value, script.duration, script.delay, script.timingFunction)
        );

        return this;
    },

    /**
     *
     * @param {string} offset
     */
    getSetup: function(offset) {
        return this.setups[offset];
    },

    getPropValue: function(state, prop) {
        return (undefined === state[prop]) ? this.getPropDefaultValue(prop) : state[prop];
    },

    getPropDiffVal: function(prop, from, to) {
        if (prop.toLowerCase().indexOf('color') > -1) {
            throw 'unsupported property ' + prop;
        }

        return to - from;
    },

    createPropDiff: function(script) {
        var prop = script.property;
        var toValue;

        if (typeof script.value === 'string' &&
            (script.value.indexOf('+') === 0 ||
            script.value.indexOf('-') === 0)
        ) {
            toValue = this.getPropValue(this.state, prop) + parseInt(script.value);
        } else {
            toValue = script.value;
        }

        this.propDiff[script.property] = {
            prop: prop,
            diffVal: this.getPropDiffVal(
                script.property,
                this.getPropValue(this.state, prop),
                toValue
            ),
            fromVal: this.getPropValue(this.state, prop)
        };
    },

    patchPropDiff: function(propDiff, script) {
        var prop = script.property;
        var toValue;

        if (typeof script.value === 'string' &&
            (script.value.indexOf('+') === 0 ||
            script.value.indexOf('-') === 0)
        ) {
            toValue = this.getPropValue(this.intermediateState, prop) + parseInt(script.value);
        } else {
            toValue = script.value;
        }

        propDiff.diffVal = this.getPropDiffVal(
            script.property,
            this.getPropValue(this.intermediateState, prop),
            toValue
        );
        propDiff.fromVal = this.getPropValue(this.intermediateState, prop);
    },

    getPropDiff: function(offset) {
        return this.propDiff[offset];
    },

    /**
     *
     * @param {object} propDIff
     * @param {float} progress
     */
    updateIntermediateState: function(propDiff, progress) {
        this.intermediateState[propDiff.prop] = progress * propDiff.diffVal + propDiff.fromVal;
    },

    update: function(setupOffset) {
        this.render(setupOffset === undefined ? Obj.OPEN_SETUP : setupOffset);
    },

    stop: function(setupOffset) {
        this.complete();

        var setup = this.getSetup(setupOffset);

        if (setup.setups.length > 0) {
            setup.index = 0;
        }
    },

    render: function() {
        var setup = this.currentSetup;

        if (!setup) {
            return;
        }

        if (setup.setups.length > 0) {
            var loopSetup = setup.setups[setup.index];
            // loop

            if (!loopSetup.startTimestamp) {
                loopSetup.startTimestamp = JStage.now();
            }

            var startTimestamp;
            var currentTimestamp = this.getCurrentTimestamp();
            var scripts = loopSetup.scripts;
            var complete;

            scripts.forEach(function(script) {
                if (script.isComplete() || script.isSkip()) {
                    return;
                }

                startTimestamp = loopSetup.startTimestamp;

                complete = false;

                if (script.delay > 0) {
                    startTimestamp += script.delay;
                }

                if (startTimestamp > currentTimestamp) {
                    return;
                }

                var progress = (currentTimestamp - startTimestamp) / script.duration;

                if (progress > 1) {
                    progress = 1;
                }

                script.executing();

                if (undefined === this.executingScripts[script.property]) {
                    this.executingScripts[script.property] = script;
                    // create prop diff
                    this.createPropDiff(script);
                }

                if (this.executingScripts[script.property] !== script &&
                    !(script.isSkip() || script.isComplete())
                ) {
                    if (this.executingScripts[script.property].isExecuting()) {
                        this.executingScripts[script.property].skip();
                    }

                    this.executingScripts[script.property] = script;
                    // patch prop diff
                    this.patchPropDiff(this.getPropDiff(script.property), script);
                }

                this.updateIntermediateState(this.getPropDiff(script.property), progress);

                if (progress === 1) {
                    script.complete();
                }
            }, this);

            if (complete !== false) {
                loopSetup.startTimestamp = null;

                if (setup.index >= (setup.setups.length - 1)) {
                    setup.index = 0;
                } else {
                    setup.index++;
                }

                this.standbyLoop(setup);
            }
        } else {
            if (!setup.startTimestamp) {
                setup.startTimestamp = this.getStartTimestamp();
            }

            var startTimestamp;
            var currentTimestamp = this.getCurrentTimestamp();
            var scripts = setup.scripts;
            var complete;

            scripts.forEach(function(script) {
                if (script.isComplete() || script.isSkip()) {
                    return;
                }

                startTimestamp = setup.startTimestamp;

                complete = false;

                if (script.delay > 0) {
                    startTimestamp += script.delay;
                }

                if (startTimestamp > currentTimestamp) {
                    return;
                }

                var progress = (currentTimestamp - startTimestamp) / script.duration;

                if (progress > 1) {
                    progress = 1;
                }

                script.executing();

                if (undefined === this.executingScripts[script.property]) {
                    this.executingScripts[script.property] = script;
                    // create prop diff
                    this.createPropDiff(script);
                }

                if (this.executingScripts[script.property] !== script &&
                    !(script.isSkip() || script.isComplete())
                ) {
                    if (this.executingScripts[script.property].isExecuting()) {
                        this.executingScripts[script.property].skip();
                    }

                    this.executingScripts[script.property] = script;
                    // patch prop diff
                    this.patchPropDiff(this.getPropDiff(script.property), script);
                }

                this.updateIntermediateState(this.getPropDiff(script.property), progress);

                if (progress === 1) {
                    script.complete();
                }
            }, this);

            if (complete === false) {
                this.status = Obj.IS_ANIMATING;
            } else {
                this.status = Obj.IS_COMPLETED;
                setup.startTimestamp = null;
            }
        }

        this.renderState();
    },

    renderState: function() {
        var transformStyle = '';

        for (var prop in this.intermediateState) {
            if (Obj.TRANSFORMS.indexOf(prop) > -1) {
                switch (prop) {
                    case 'translateX':
                    case 'translateY':
                        transformStyle += prop + '(' + this.intermediateState[prop] + this.getScale() + 'px) ';
                        break;
                    case 'rotate':
                    case 'skew':
                    case 'skewX':
                    case 'skewY':
                        transformStyle += prop + '(' + this.intermediateState[prop] + 'deg) ';
                        break;
                    case 'scale':
                    case 'scaleX':
                    case 'scaleY':
                        transformStyle += prop + '(' + this.intermediateState[prop] + ') ';
                        break;
                }
            } else {
                if (['left', 'top', 'width', 'height'].indexOf(prop) > -1) {
                    this.el.style[prop] = this.intermediateState[prop] * this.getScale() + 'px';
                } else {
                    this.el.style[prop] = this.intermediateState[prop];
                }
            }
        }

        if (undefined !== transformStyle) {
            JStage.setStyle(this.el, 'transform', transformStyle);
        }
    },

    /**
     * 设置物体尺寸
     * @param {int} width
     * @param {int} height
     * @returns {this}
     */
    setSize: function(width, height) {
        this.width = width;
        this.height = height;

        this.setState('width', width)
            .setState('height', height);

        return this;
    },

    /**
     * 设置物体位置
     * @param {int} left
     * @param {int} top
     * @returns {this}
     */
    setPosition: function(left, top) {
        this.left = left;
        this.top = top;

        this.setState('left', left)
            .setState('top', top);

        return this;
    },

    /**
     * 获得当前元素的缩放比例
     * @returns {float}
     */
    getScale: function() {
        return this.stage.scale;
    },

    /**
     * 获得当前舞台的开始时间戳
     * @returns {float}
     */
    getStartTimestamp: function() {
        return this.stage.startTimestamp;
    },

    /**
     * 获得当前舞台的当前时间戳
     * @returns {float}
     */
    getCurrentTimestamp: function() {
        return this.stage.currentTimestamp;
    },

    /**
     * Get the object ready, placing and style it.
     */
    getReady: function() {
        var openSetup = this.getSetup(Obj.OPEN_SETUP);

        if (undefined !== openSetup) {
            this.resetSetup(openSetup);
            this.duration = this.getDuration(openSetup);
        }

        // 重置中间状态
        this.intermediateState = {};

        // 初始化元素样式状态，包括当前状态以及阶段状态
        for (var prop in this.state) {
            this.intermediateState[prop] = this.state[prop];
        }

        this.renderState();
    },

    /**
     * 
     * @param {*} setupOffset 
     */
    getSetupReady: function(setupOffset) {
        // 重置中间状态
        this.intermediateState = {};

        var setup = this.getSetup(setupOffset);
        var finState = this.getFinState(setup);

        for (var prop in setup.scripts) {
            if (undefined === finState[prop]) {
                finState[prop] = setup.scripts[prop];
            }
        }

        for (var prop in finState) {
            this.intermediateState[prop] = finState[prop];
        }

        this.duration = this.getDuration(setup);
        this.renderState();
    },

    /**
     * Set object dom
     * @param {mixed} el 
     */
    setEl: function(el) {
        this.el = JStage.getEl(el);
    },

    /**
     * Check if the object is animating
     * @returns {boolean}
     */
    isAnimating: function() {
        return this.status === Obj.IS_ANIMATING;
    },

    /**
     * Check if the object's animation is complete
     * @returns {boolean}
     */
    isCompleted: function() {
        return this.status === Obj.IS_COMPLETED;
    },

    /**
     * Set object animation is completed.
     */
    complete: function() {
        this.status = Obj.IS_COMPLETED;
    },

    /**
     * 判断元素是否是静止元素
     * @returns {boolean}
     */
    isStatic: function() {
        return this.status === Obj.IS_STATIC;
    },

    /**
     * 判断元素是否是等待动画执行状态
     * @returns {boolean}
     */
    isIdle: function() {
        return this.status === Obj.IS_IDLE;
    },

    /**
     * 重计算部分脚本
     * 主要用于更新场景大小变化后元素的各种尺寸和位置相关属性
     */
    recal: function() {
        if (!this.isAnimating()) {
            this.renderState();
        }
    },

    /**
     * 将物体添加到指定的舞台上
     * @param {JStage.Stage} stage
     */
    appendToStage: function(stage) {
        stage.appendObj(this);
    },

    /**
     * 设置物体到指定的舞台上
     * @param {JStage.setStage} stage
     */
    setStage: function(stage) {
        this.stage = stage;
    },

    /**
     * 重置舞台元素状态
     */
    reset: function() {
        this.getReady();
    },

    /**
     * 设置舞台播放到指定毫秒数
     * @param {int} time 舞台播放到指定毫秒数
     */
    setTime: function(time) {
        //
    },

    /**
     * 获得动画时间，这个时间包含延迟时间
     * @param {object} setup
     * @returns {int}
     */
    getDuration: function(setup) {
        var duration = 0;
        var scriptDuration = 0;

        setup.scripts.forEach(function(script) {
            scriptDuration = script.duration + script.delay;

            if (duration < scriptDuration) {
                duration = scriptDuration;
            }
        });

        return duration;
    },

    /**
     * 获得设置的最终状态，需要处理同属性延迟执行的情况，比如两个left移动先后执行
     * @param {object} setup
     */
    getFinState: function(setup) {
        var finState = {};
        var propDelay = {};

        setup.scripts.forEach(function(script) {
            if (undefined === propDelay[script.property]) {
                propDelay[script.property] = script.delay;
                finState[script.property] = script.property;
            } else if (script.delay > propDelay[script.property]) {
                propDelay[script.property] = script.delay;
                finState[script.property] = script.property;
            }
        });

        return finState;
    },

    /**
     * Reset setup status, include scripts in the setup
     * @param {object} setup
     */
    resetSetup: function(setup) {
        setup.scripts.forEach(function(script) {
            /**
             * Reset script status
             */
            script.reset();
        });
    },

    /**
     * Get the setup ready
     * @param {Object|string} offset 
     */
    standby: function(offset) {
        var setup = typeof offset === 'object' ? offset : this.getSetup(offset);

        if (undefined === setup) {
            return;
        }

        /**
         * If the setup is a loop setup, should get the setups in this ready
         */
        if (setup.setups.length > 0) {
            setup.setups.forEach(function(loopSetup) {
                this.standby(loopSetup);
            }, this);
        }

        this.currentSetup = setup;
        setup.startTimestamp = null;
        this.status = Obj.IS_IDLE;
        this.resetSetup(setup);
    },

    /**
     * Get the setup in side the loop ready
     * @param {Object} setup Loop setup
     */
    standbyLoop: function(setup) {
        this.standby(setup.setups[setup.index]);

        // Override current setup to current loop setup
        this.currentSetup = setup;
    },

    /**
     * Check if object has specified setup
     * @param {string} offset 
     */
    hasSetup: function(offset) {
        return undefined !== this.setups[offset];
    }
};

/**
 * 舞台构造函数
 * @constructor
 * @param {int} el
 * @param {int} width 舞台的标准宽度，不是元素的实际宽度
 * @param {int} height 舞台的标准高度，不是元素的实际高度
 */
function JStage(el, width, height) {
    this.el = JStage.getEl(el);
    this.width = width, this.height = height, this.scale, this.startTimestamp, this.currentTimestamp, this.duration = 0, this.status = JStage.IS_IDLE, this.currentSetupOffsets = [], this.loops = [], this.resources = [], this.objs = [];
}

JStage.interval = 13;

JStage.now = function() {
    if (performance && performance.now) {
        return performance.now();
    } else {
        return Date.now();
    }
};

JStage.setStyle = function(node, property, value) {
    var prefixs = ['ms', 'webkit', 'moz'];

    if (node.style[property] !== undefined) {
        node.style[property] = value;
    } else {
        var propertyName;
        property = property.charAt(0).toUpperCase() + property.slice(1);

        for (var i = 0, l = prefixs.length; i < l; i++) {
            propertyName = prefixs[i] + property;

            if (node.style[propertyName] !== undefined) {
                node.style[propertyName] = value;
                break;
            }
        }
    }
};

JStage.getEl = function(el) {
    if (typeof el === 'string') {
        return document.querySelector(el);
    } else if (el instanceof jQuery) {
        return el[0];
    } else if (typeof el === 'object' &&
        (el instanceof Node && el.nodeType > 0)
    ) {
        return el;
    } else {
        throw 'Invalid el';
    }
};

JStage.normalizeTime = function(time) {
    if (!time) {
        return 0;
    }

    if (typeof time === 'number') {
        return time;
    } else if (time.indexOf('ms') > 0) {
        return time.slice(0, -2) - 0;
    } else if (time.indexOf('s') > 0) {
        return time.slice(0, -1) * 1000;
    } else if (isNaN(time)) {
        return time;
    }
};

JStage.getStyle = function(el, prop) {
    if (typeof getComputedStyle === undefined) {
        return el.currentStyle[prop];
    } else {
        return getComputedStyle(el, null).getPropertyValue(prop);
    }
};

JStage.IS_IDLE = 0;
JStage.IS_FINISHED = 1;
JStage.IS_ANIMATING = 2;

JStage.prototype = {
    /**
     * 添加资源
     * @param {string} resource
     */
    addResource: function(resource) {
        if (this.resources.indexOf(resource) < 0) {
            this.resources.push(resource);
        }

        return this;
    },

    loadResources: function(callbacks) {
        var len = this.resources.length;
        var loadedLen = 0;

        this.resources.forEach(function(resource) {
            var image = new Image;
            image.onload = function() {
                loadedLen++;

                if (callbacks.onProgress && typeof callbacks.onProgress === 'function') {
                    callbacks.onProgress.call(this, len, loadedLen);
                }

                if (loadedLen === len && callbacks.onComplete && typeof callbacks.onComplete === 'function') {
                    callbacks.onComplete.call(null);
                }
            };

            image.src = resource;

            if (image.complete) {
                image.load();
            }
        });
    },

    /**
     * 在舞台上创建一个物体
     * @param {mixed} el 元素对象
     * @param {int} width
     * @param {int} height
     * @param {int} left
     * @param {int} right
     * @returns {Obj}
     */
    createObj: function(el, width, height, left, right) {
        var obj = new Obj(el, width, height, left, right);
        this.appendObj(obj);
        return obj;
    },

    isAnimating: function() {
        return this.status === JStage.IS_ANIMATING;
    },

    inSetup: function(setupOffset) {
        return this.currentSetupOffsets.indexOf(setupOffset) > -1;
    },

    addCurrentSetupOffset: function(setupOffset) {
        if (this.currentSetupOffsets.indexOf(setupOffset) < 0) {
            this.currentSetupOffsets.push(setupOffset);
        }
    },

    removeFromCurrentSetups: function(setupOffset) {
        var index = this.currentSetupOffsets.indexOf(setupOffset);

        if (index > -1) {
            this.currentSetupOffsets.splice(index, 1);
        }
    },

    /**
     * 初始化舞台
     */
    init: function() {
        var self = this;

        this.setScale(this.el.offsetWidth, this.el.offsetHeight);

        this.el.style.width = this.width * this.scale + 'px';
        this.el.style.height = this.height * this.scale + 'px';

        // 将舞台元素准备到位
        this.objs.forEach(function(obj) {
            obj.getReady();

            if (obj.duration > self.duration) {
                self.duration = obj.duration;
            }
        });
    },

    standby: function(setupOffset) {
        this.startTimestamp = null;
        this.currentTimestamp = null;

        if (undefined === setupOffset) {
            return;
        }

        this.objs.forEach(function(obj) {
            obj.standby(setupOffset);
        }, this);
    },

    /**
     * 重置舞台元素实际尺寸
     * @param {int|float} width
     * @param {int|float} height
     */
    resizeEl: function(width, height) {
        this.setScale(width, height);

        // 设置舞台元素的尺寸
        this.el.style.width = this.width * this.scale + 'px';
        this.el.style.height = this.height * this.scale + 'px';

        this.objs.forEach(function(obj) {
            obj.recal();
        });
    },

    /**
     * 设置舞台的缩放比例
     * @param {int|float} width 舞台元素实际宽度
     * @param {int|float} height 舞台元素实际宽度
     */
    setScale: function(width, height) {
        var wScale = width / this.width;
        var hScale = height / this.height;

        if (wScale > hScale) {
            this.scale = hScale;
        } else {
            this.scale = wScale;
        }

        return this;
    },

    start: function() {
        this.startSetup(Obj.OPEN_SETUP);
    },

    startSetup: function(setupOffset) {
        this.addCurrentSetupOffset(setupOffset);
        this.standby(setupOffset);

        this.startTimestamp = JStage.now();

        if (!this.isAnimating()) {
            this.status = JStage.IS_ANIMATING;

            if (window.requestAnimationFrame) {
                window.requestAnimationFrame(this.update.bind(this));
            } else {
                setTimeout(this.update.bind(this), JStage.interval);
            }
        }
    },

    stopSetup: function(offset) {
        this.objs.forEach(function(obj) {
            if (obj.hasSetup(offset)) {
                obj.stop(offset);
            }
        });
    },

    update: function(timestamp) {
        this.currentTimestamp = timestamp ? timestamp : JStage.now();

        this.updateSetup(timestamp);

        if (window.requestAnimationFrame) {
            window.requestAnimationFrame(this.update.bind(this));
        } else {
            setTimeout(this.update.bind(this), JStage.interval);
        }
    },

    updateSetup: function() {
        this.currentSetupOffsets.forEach(function(setupOffset) {
            var finished;

            this.objs.forEach(function(obj) {

                // console.log(setupOffset, obj, obj.hasSetup(setupOffset), obj.isStatic(), obj.isCompleted());

                if (obj.hasSetup(setupOffset) &&
                    !(obj.isStatic() || obj.isCompleted())
                ) {
                    finished = false;
                    obj.update(setupOffset);
                }
            }, this);

            if (finished === undefined) {
                this.removeFromCurrentSetups(setupOffset);
            }
        }, this);
    },

    setTime: function(time) {
        //
    },

    setProgress: function(progress) {
        //
    },

    /**
     * 往舞台上添加物体
     * @param {JShow.Obj} obj
     */
    appendObj: function(obj) {
        if (!obj.stage && obj.stage !== this) {
            this.objs.push(obj);
            obj.setStage(this);
        }
    }
};

return JStage;

})));

//# sourceMappingURL=maps/JStage.min.js.map
